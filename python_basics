                                ## GENERATORS:
#         Generators are a way to create iterators in Python using functions and the yield keyword.
#         They allow you to generate values one at a time as needed, rather than computing and storing all values in memory upfront.
#
# #ADVANTAGES:
#
#         Memory Efficient:
#                        They donâ€™t store the entire sequence in memory; instead, they yield items one at a time.
#         Lazy Evaluation:
#                        Values are computed only when needed, which can improve performance for large datasets.
#         Readable Code:
#                        Simplifies implementation of iterators.
#
#
# #DISADVANTAGES:
#
#         Single Iteration:
#                 Generators can only be iterated once. To re-iterate, you need to create a new generator.
#         Debugging:
#                 Difficult to debug as the state is not stored explicitly.
#         Limited Access:
#                 Cannot access elements by index or use slicing.



# #USE CASES:
#         Reading large files line by line.
#         Generating infinite sequences (e.g., Fibonacci numbers).
#         Streaming data processing.


# #EXAMPLES:

# def generate_numbers(n):
#     for i in range(n):
#         yield i
#
# # Usage
# for number in generate_numbers(5):
#     print(number)


# #EXAMPLE 2:
#
# def infinite_counter():
#     count = 0
#     while True:
#         yield count
#         count += 1
#
# # Usage
# counter = infinite_counter()
# for _ in range(6):
#     print(next(counter))



                                                  ##Iterators

# #ITERATORS:
#        An iterator is an object that allows traversal through all the elements of a collection
             (e.g., list, tuple) one at a time, without needing to use indexing.
#        It implements the _iter() and __next_() methods.
#
# #ADVANTAGES:
#         Memory Efficiency:
#                        They do not store the entire data in memory; instead, they generate items on the fly.
#         Lazy Evaluation:
#                        Useful for handling large datasets or infinite sequences without loading everything at once.
#         Improves Code Readability:
#                        Simplifies looping through data structures.
#
# #DISADVANTAGES:
#
#         One-Time Use:
#                  Once traversed, they cannot be reused without reinitializing.
#         Lack of Indexing:
#                  Cannot directly access elements using indices.
#         Debugging Challenges:
#                  Traversing can make debugging more complex.
#
#
#
# #EXAMPLES:
#  my_list = [1, 2, 3, 4]
#  iterator = iter(my_list)
#
# print(next(iterator))  # Output: 1
# print(next(iterator))  # Output: 2



# #EXAMPLES 2:

# import itertools
#
# counter = itertools.count(start=1, step=2)  # Infinite odd numbers
# for _ in range(5):
#     print(next(counter))  # Output 1,3,5,7,9

#                                                    ##LIST COMPREHENSION
#
# LIST COMPREHENSION:
#             List comprehension is a concise way to create lists in Python.
#             It allows for generating a new list by applying an expression to each element of an iterable.
#
# Syntax:
#
# [expression for item in iterable if condition]
#
# Advantages:
#         Concise and Readable:
#                           Reduces the code length compared to traditional loops.
#         Faster Execution:
#                           More efficient than for loops for simple operations.
#         Easy to Write:
#                           Simplifies list creation logic.
#
# Disadvantages:
#         Complexity:
#                   Can become hard to read with nested comprehensions.
#         Memory Usage:
#                   Consumes more memory for large datasets compared to generators.
#
# USE CASES:
#         Filtering elements from a list.
#         Applying transformations to elements.
#         Flattening nested lists.


# EXAMPLES 1 :


# numbers = [1, 2, 3, 4, 5, 6]
# evens = [x for x in numbers if x % 2 == 0]
# print(evens)  # Output: [2, 4, 6]



# EXAMPLE 2:


# squares = [x**2 for x in range(1, 6)]
# print(squares)  # Output: [1, 4, 9, 16, 25]





#                                             ##  DICT COMPREHENSION
#
#
# #DICT COMPREHENSION:
# A dict comprehension is a concise way to create dictionaries in Python by generating key-value pairs from an iterable or another dictionary in a single line of code.
#
# ADVANTAGES:
#             Conciseness:
#                      Reduces the need for verbose loops.
#             Performance:
#                      Often faster than traditional loops.
#             Readability:
#                      Easy to understand for simple operations.
#
# DISADVANTAGES:
#
#             Complexity:
#             Can become hard to read with complex logic.
#             Debugging:
#             Difficult to debug compared to a traditional loop.
#
# USE CASES:
#             Transforming or filtering an existing dictionary.
#             Creating dictionaries from other iterables (e.g., lists, sets).
#             Inverting keys and values of a dictionary.
#
#
#
# EXAMPLES 1:

# # Original dictionary
# prices = {'apple': 100, 'banana': 30, 'cherry': 150}
#
# # Comprehension: Filter items with price > 50
# filtered_prices = {key: value for key, value in prices.items() if value > 50}
# print(filtered_prices)  # Output: {'apple': 100, 'cherry': 150}



# EXAMPLE 2:

# List of numbers
# numbers = [1, 2, 3, 4, 5]
#
# # Comprehension: Square of each number as value
# squared_dict = {num: num ** 2 for num in numbers}
# print(squared_dict)  # Output: {1: 1, 2: 4, 3: 9,4:16,5:25}